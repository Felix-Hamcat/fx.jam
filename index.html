<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculateur Pitch/Tempo Pro - Repitch DJ & Production Musicale</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="Calculateur de pitch et tempo pour DJs et producteurs. Calculez facilement le repitch, l'étirement temporel et l'adaptation de BPM pour vos tracks et samples musicaux.">
    <meta name="keywords" content="pitch shifter, calculateur tempo, repitch DJ, BPM calculator, time stretching, pitch bend, DJ tools, production musicale, sample adaptation, key matching, harmonic mixing, cents calculator, semitones calculator, music producer tools, DJ mixing, tempo sync, pitch correction, audio tools, music technology, beatmatching, key detection, frequency shift, music math, studio tools, remix tools, mashup tools, turntable pitch, CDJ pitch, serato pitch, virtual DJ, traktor pitch, logic pitch, ableton pitch, pro tools pitch, cubase pitch, fl studio pitch, reason pitch, reaper pitch, studio one pitch">
    <meta name="author" content="DJ Tools">
    <meta name="robots" content="index, follow">
    
    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="Calculateur Pitch/Tempo - Outil DJ & Production">
    <meta property="og:description" content="Calculez précisément le repitch et l'adaptation de tempo pour vos tracks DJ et samples de production musicale.">
    <meta property="og:type" content="website">
    <meta property="og:image" content="/pitch-tempo-calculator.png">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Calculateur Pitch/Tempo - Outil DJ & Production">
    <meta name="twitter:description" content="Calculez précisément le repitch et l'adaptation de tempo pour vos tracks DJ et samples de production musicale.">
    
    <!-- Structured Data JSON-LD -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "Calculateur Pitch/Tempo Pro",
        "description": "Outil professionnel pour calculer le pitch, tempo et repitch musical pour DJs et producteurs",
        "url": "#",
        "applicationCategory": "Music",
        "operatingSystem": "Web Browser",
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "EUR"
        },
        "creator": {
            "@type": "Organization",
            "name": "DJ Tools"
        }
    }
    </script>
    
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(-45deg, #1e3c72, #2a5298, #667eea, #764ba2);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 8px;
            margin: 0;
            overflow: hidden;
        }

        .container {
            background: rgba(15, 15, 25, 0.9);
            backdrop-filter: blur(20px) saturate(180%);
            border-radius: 16px;
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
            padding: 12px;
            width: 100%;
            max-width: 800px;
            max-height: 95vh;
            position: relative;
            transition: all 0.3s ease;
            overflow-y: auto;
        }

        .container:hover {
            transform: scale(1.005);
            box-shadow: 
                0 25px 50px rgba(0, 0, 0, 0.5),
                0 0 0 1px rgba(255, 255, 255, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .header {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 10px;
        }

        h1 {
            color: #ffd93d;
            text-shadow: 
                0 0 10px rgba(255, 217, 61, 0.8),
                2px 2px 0 #1e3c72,
                -2px -2px 0 #1e3c72,
                2px -2px 0 #1e3c72,
                -2px 2px 0 #1e3c72;
            font-size: 1.4em;
            font-weight: 700;
            letter-spacing: -0.02em;
        }

        .tracks-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 10px;
        }

        .track {
            background: rgba(255, 255, 255, 0.02);
            border-radius: 12px;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .track-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .track-title {
            font-weight: 600;
            color: #e0e6ff;
            font-size: 12px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }

        .track-a { color: #ff6b6b; }
        .track-b { color: #4ecdc4; }

        .harmonic-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }

        .harmonic-indicator.compatible {
            background: #00c851;
            box-shadow: 0 0 8px rgba(0, 200, 81, 0.6);
        }

        /* Couleurs des notes (style Traktor) */
        .note-btn[data-note="C"] { --note-color: #ff0000; }
        .note-btn[data-note="C#"] { --note-color: #ff8000; }
        .note-btn[data-note="D"] { --note-color: #ffff00; }
        .note-btn[data-note="D#"] { --note-color: #80ff00; }
        .note-btn[data-note="E"] { --note-color: #00ff00; }
        .note-btn[data-note="F"] { --note-color: #00ff80; }
        .note-btn[data-note="F#"] { --note-color: #00ffff; }
        .note-btn[data-note="G"] { --note-color: #0080ff; }
        .note-btn[data-note="G#"] { --note-color: #0000ff; }
        .note-btn[data-note="A"] { --note-color: #8000ff; }
        .note-btn[data-note="A#"] { --note-color: #ff00ff; }
        .note-btn[data-note="B"] { --note-color: #ff0080; }

        .note-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 4px;
            margin-bottom: 6px;
            perspective: 1000px;
        }

        .note-btn {
            padding: 6px 2px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 600;
            text-align: center;
            font-size: 9px;
            color: #b8c5ff;
            position: relative;
            overflow: hidden;
            transform-style: preserve-3d;
        }

        .note-btn:hover {
            transform: translateY(-1px) rotateX(5deg);
            box-shadow: 
                0 4px 12px rgba(102, 126, 234, 0.3),
                0 0 0 1px var(--note-color, rgba(255, 255, 255, 0.2));
            border-color: var(--note-color, rgba(102, 126, 234, 0.5));
            color: #fff;
        }

        .note-btn.selected {
            background: var(--note-color, linear-gradient(135deg, #667eea, #764ba2));
            color: white;
            border-color: var(--note-color, #667eea);
            transform: translateY(-1px);
            box-shadow: 
                0 4px 12px rgba(102, 126, 234, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .detune-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 6px auto;
        }

        .detune-label {
            color: #b8c5ff;
            font-size: 9px;
            font-weight: 600;
            margin-bottom: 3px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .detune-input {
            width: 45px;
            padding: 4px 3px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 4px;
            color: #b8c5ff;
            font-size: 9px;
            font-weight: 600;
            text-align: center;
            outline: none;
            transition: all 0.3s ease;
            -webkit-appearance: none;
            -moz-appearance: textfield;
        }

        .detune-input::-webkit-outer-spin-button,
        .detune-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .detune-input:focus {
            border-color: #667eea;
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
        }

        .slider-container {
            position: relative;
            margin-bottom: 6px;
        }

        .bpm-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 4px;
            border-radius: 4px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            outline: none;
            opacity: 0.8;
            transition: opacity 0.3s;
            cursor: pointer;
        }

        .bpm-slider:hover {
            opacity: 1;
        }

        .bpm-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ffd93d, #ffb347);
            cursor: pointer;
            border: 2px solid rgba(255, 255, 255, 0.8);
            box-shadow: 
                0 2px 8px rgba(255, 217, 61, 0.4),
                0 0 0 2px rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .bpm-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 
                0 3px 12px rgba(255, 217, 61, 0.6),
                0 0 0 3px rgba(255, 255, 255, 0.2);
        }

        .bpm-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ffd93d, #ffb347);
            cursor: pointer;
            border: 2px solid rgba(255, 255, 255, 0.8);
            box-shadow: 
                0 2px 8px rgba(255, 217, 61, 0.4),
                0 0 0 2px rgba(255, 255, 255, 0.1);
        }

        .bpm-display {
            text-align: center;
            color: #e0e6ff;
            font-size: 13px;
            font-weight: 600;
            margin-top: 4px;
            text-shadow: 
                1px 1px 0 #1e3c72,
                -1px -1px 0 #1e3c72,
                1px -1px 0 #1e3c72,
                -1px 1px 0 #1e3c72;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .bpm-display:hover {
            color: #ffd93d;
            transform: scale(1.05);
        }

        .bpm-input {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 25, 0.95);
            border: 2px solid #667eea;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 16px;
            font-weight: 600;
            color: #e0e6ff;
            text-align: center;
            width: 120px;
            outline: none;
            display: none;
            z-index: 1000;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
        }

        .bpm-input:focus {
            border-color: #ffd93d;
            box-shadow: 0 0 15px rgba(255, 217, 61, 0.4), 0 8px 25px rgba(0, 0, 0, 0.5);
        }

        .bpm-controls {
            display: flex;
            gap: 4px;
            margin-top: 4px;
        }

        .bpm-btn {
            flex: 1;
            padding: 4px 6px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            color: #b8c5ff;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .bpm-btn:hover {
            background: rgba(102, 126, 234, 0.2);
            border-color: rgba(102, 126, 234, 0.5);
            color: #fff;
            transform: translateY(-1px);
        }

        .bpm-btn:active {
            transform: translateY(0);
        }

        .results-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .result {
            background: linear-gradient(135deg, #ff9500, #ff6b00);
            color: white;
            padding: 8px;
            border-radius: 10px;
            text-align: center;
            font-weight: 600;
            height: 55px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(255, 149, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .result.perfect {
            background: linear-gradient(135deg, #00c851, #007e33);
            box-shadow: 0 4px 15px rgba(0, 200, 81, 0.3);
        }

        .result:not(.empty) {
            animation: resultPulse 0.5s ease;
        }

        @keyframes resultPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        .result.empty {
            background: rgba(255, 255, 255, 0.05);
            color: rgba(255, 255, 255, 0.4);
            box-shadow: none;
            border-color: rgba(255, 255, 255, 0.1);
        }

        .result-main {
            font-size: 13px;
            margin-bottom: 2px;
            font-weight: 700;
            letter-spacing: -0.02em;
            text-shadow: 
                0 0 6px rgba(255, 255, 255, 0.5),
                1px 1px 0 rgba(0, 0, 0, 0.3);
            position: relative;
            z-index: 1;
        }

        .result-details {
            font-size: 9px;
            opacity: 0.9;
            font-weight: 500;
            letter-spacing: 0.3px;
            position: relative;
            z-index: 1;
            line-height: 1.1;
            text-shadow: 
                1px 1px 0 rgba(0, 0, 0, 0.2);
        }

        .pitch-info {
            font-size: 8px;
            color: #4ecdc4;
            margin-top: 2px;
            font-weight: 600;
        }

        .footer {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            margin-top: 8px;
            width: 100%;
        }

        .middle-ground-container {
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-items: center;
        }

        .middle-ground-buttons {
            display: flex;
            gap: 6px;
        }

        .suggestion-text {
            font-size: 9px;
            color: #4ecdc4;
            font-weight: 500;
            text-align: center;
            opacity: 0.8;
        }

        .export-btn, .middle-ground-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 8px;
            padding: 5px 12px;
            color: white;
            font-size: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .middle-ground-btn {
            width: 85px;
        }

        .export-btn {
            width: 120px;
        }

        .middle-ground-btn.recommended {
            background: linear-gradient(135deg, #00c851, #007e33);
            box-shadow: 0 0 10px rgba(0, 200, 81, 0.4);
        }

        .export-btn:hover, .middle-ground-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .middle-ground-btn {
            background: linear-gradient(135deg, #ff6b6b, #ee5a6f);
        }

        /* Animations d'entrée */
        .track {
            animation: slideInUp 0.6s ease forwards;
            opacity: 0;
            transform: translateY(20px);
        }

        .track:nth-child(1) { animation-delay: 0.1s; }
        .track:nth-child(2) { animation-delay: 0.2s; }

        @keyframes slideInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Responsive pour mobile */
        @media (max-width: 768px) {
            .container {
                padding: 10px;
                max-width: 95vw;
            }
            
            .tracks-container {
                grid-template-columns: 1fr;
                gap: 8px;
            }
            
            .results-container {
                grid-template-columns: 1fr;
                gap: 6px;
            }
            
            .header {
                flex-direction: row;
                gap: 8px;
                align-items: center;
                justify-content: center;
            }
            
            .middle-ground-buttons {
                gap: 4px;
            }
            
            .middle-ground-btn {
                width: 70px;
                font-size: 9px;
                padding: 4px 8px;
            }
            
            .export-btn {
                width: 100px;
                font-size: 9px;
                padding: 4px 12px;
            }
            
            .suggestion-text {
                font-size: 8px;
            }
            
            h1 {
                text-align: center;
                font-size: 1.2em;
            }
            
            .note-btn {
                padding: 5px 1px;
                font-size: 8px;
            }
            
            .result {
                height: 50px;
            }
            
            .result-main {
                font-size: 12px;
            }
            
            .result-details {
                font-size: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎵 Pitch/Tempo Pro</h1>
        </div>
        
        <div class="tracks-container">
            <!-- Track A -->
            <div class="track">
                <div class="track-header">
                    <div class="track-title track-a">Track A</div>
                    <div class="harmonic-indicator" id="harmonicA"></div>
                </div>
                
                <div class="note-grid" id="fromGridA">
                    <div class="note-btn" data-note="C" onclick="selectNote(this, 'fromA', 'C')">C</div>
                    <div class="note-btn" data-note="C#" onclick="selectNote(this, 'fromA', 'C#')">C#/Db</div>
                    <div class="note-btn" data-note="D" onclick="selectNote(this, 'fromA', 'D')">D</div>
                    <div class="note-btn" data-note="D#" onclick="selectNote(this, 'fromA', 'D#')">D#/Eb</div>
                    <div class="note-btn" data-note="E" onclick="selectNote(this, 'fromA', 'E')">E</div>
                    <div class="note-btn" data-note="F" onclick="selectNote(this, 'fromA', 'F')">F</div>
                    <div class="note-btn" data-note="F#" onclick="selectNote(this, 'fromA', 'F#')">F#/Gb</div>
                    <div class="note-btn" data-note="G" onclick="selectNote(this, 'fromA', 'G')">G</div>
                    <div class="note-btn" data-note="G#" onclick="selectNote(this, 'fromA', 'G#')">G#/Ab</div>
                    <div class="note-btn selected" data-note="A" onclick="selectNote(this, 'fromA', 'A')">A</div>
                    <div class="note-btn" data-note="A#" onclick="selectNote(this, 'fromA', 'A#')">A#/Bb</div>
                    <div class="note-btn" data-note="B" onclick="selectNote(this, 'fromA', 'B')">B</div>
                </div>
                
                <div class="detune-container">
                    <div class="detune-label">Fine</div>
                    <input type="number" class="detune-input" id="fromDetuneA" value="0" min="-50" max="50" step="1" oninput="calculate()">
                </div>
                
                <div class="slider-container">
                    <input type="range" class="bpm-slider" id="currentSliderA" min="1" max="240" value="120" step="0.001" oninput="updateFromSlider('currentA')">
                    <div class="bpm-display" id="currentDisplayA" onclick="editBpm('currentA')">120.000</div>
                    <input type="number" class="bpm-input" id="currentInputA" min="1" max="999" step="0.001" onblur="finishEditBpm('currentA')" onkeydown="handleKeydown(event, 'currentA')">
                </div>
                
                <div class="note-grid" id="toGridA">
                    <div class="note-btn" data-note="C" onclick="selectNote(this, 'toA', 'C')">C</div>
                    <div class="note-btn" data-note="C#" onclick="selectNote(this, 'toA', 'C#')">C#/Db</div>
                    <div class="note-btn" data-note="D" onclick="selectNote(this, 'toA', 'D')">D</div>
                    <div class="note-btn" data-note="D#" onclick="selectNote(this, 'toA', 'D#')">D#/Eb</div>
                    <div class="note-btn" data-note="E" onclick="selectNote(this, 'toA', 'E')">E</div>
                    <div class="note-btn" data-note="F" onclick="selectNote(this, 'toA', 'F')">F</div>
                    <div class="note-btn" data-note="F#" onclick="selectNote(this, 'toA', 'F#')">F#/Gb</div>
                    <div class="note-btn" data-note="G" onclick="selectNote(this, 'toA', 'G')">G</div>
                    <div class="note-btn" data-note="G#" onclick="selectNote(this, 'toA', 'G#')">G#/Ab</div>
                    <div class="note-btn" data-note="A" onclick="selectNote(this, 'toA', 'A')">A</div>
                    <div class="note-btn" data-note="A#" onclick="selectNote(this, 'toA', 'A#')">A#/Bb</div>
                    <div class="note-btn" data-note="B" onclick="selectNote(this, 'toA', 'B')">B</div>
                </div>
                
                <div class="slider-container">
                    <input type="range" class="bpm-slider" id="targetSliderA" min="1" max="240" value="120" step="0.001" oninput="updateFromSlider('targetA')">
                    <div class="bpm-display" id="targetDisplayA" onclick="editBpm('targetA')">120.000</div>
                    <input type="number" class="bpm-input" id="targetInputA" min="1" max="999" step="0.001" onblur="finishEditBpm('targetA')" onkeydown="handleKeydown(event, 'targetA')">
                </div>
                
                <div class="bpm-controls">
                    <button class="bpm-btn" onclick="divideBpm('A')" title="BPM ÷ 2">÷2</button>
                    <button class="bpm-btn" onclick="multiplyBpm('A')" title="BPM × 2">×2</button>
                </div>
            </div>

            <!-- Track B -->
            <div class="track">
                <div class="track-header">
                    <div class="track-title track-b">Track B</div>
                    <div class="harmonic-indicator" id="harmonicB"></div>
                </div>
                
                <div class="note-grid" id="fromGridB">
                    <div class="note-btn" data-note="C" onclick="selectNote(this, 'fromB', 'C')">C</div>
                    <div class="note-btn" data-note="C#" onclick="selectNote(this, 'fromB', 'C#')">C#/Db</div>
                    <div class="note-btn" data-note="D" onclick="selectNote(this, 'fromB', 'D')">D</div>
                    <div class="note-btn" data-note="D#" onclick="selectNote(this, 'fromB', 'D#')">D#/Eb</div>
                    <div class="note-btn" data-note="E" onclick="selectNote(this, 'fromB', 'E')">E</div>
                    <div class="note-btn" data-note="F" onclick="selectNote(this, 'fromB', 'F')">F</div>
                    <div class="note-btn" data-note="F#" onclick="selectNote(this, 'fromB', 'F#')">F#/Gb</div>
                    <div class="note-btn" data-note="G" onclick="selectNote(this, 'fromB', 'G')">G</div>
                    <div class="note-btn" data-note="G#" onclick="selectNote(this, 'fromB', 'G#')">G#/Ab</div>
                    <div class="note-btn selected" data-note="A" onclick="selectNote(this, 'fromB', 'A')">A</div>
                    <div class="note-btn" data-note="A#" onclick="selectNote(this, 'fromB', 'A#')">A#/Bb</div>
                    <div class="note-btn" data-note="B" onclick="selectNote(this, 'fromB', 'B')">B</div>
                </div>
                
                <div class="detune-container">
                    <div class="detune-label">Fine</div>
                    <input type="number" class="detune-input" id="fromDetuneB" value="0" min="-50" max="50" step="1" oninput="calculate()">
                </div>
                
                <div class="slider-container">
                    <input type="range" class="bpm-slider" id="currentSliderB" min="1" max="240" value="120" step="0.001" oninput="updateFromSlider('currentB')">
                    <div class="bpm-display" id="currentDisplayB" onclick="editBpm('currentB')">120.000</div>
                    <input type="number" class="bpm-input" id="currentInputB" min="1" max="999" step="0.001" onblur="finishEditBpm('currentB')" onkeydown="handleKeydown(event, 'currentB')">
                </div>
                
                <div class="note-grid" id="toGridB">
                    <div class="note-btn" data-note="C" onclick="selectNote(this, 'toB', 'C')">C</div>
                    <div class="note-btn" data-note="C#" onclick="selectNote(this, 'toB', 'C#')">C#/Db</div>
                    <div class="note-btn" data-note="D" onclick="selectNote(this, 'toB', 'D')">D</div>
                    <div class="note-btn" data-note="D#" onclick="selectNote(this, 'toB', 'D#')">D#/Eb</div>
                    <div class="note-btn" data-note="E" onclick="selectNote(this, 'toB', 'E')">E</div>
                    <div class="note-btn" data-note="F" onclick="selectNote(this, 'toB', 'F')">F</div>
                    <div class="note-btn" data-note="F#" onclick="selectNote(this, 'toB', 'F#')">F#/Gb</div>
                    <div class="note-btn" data-note="G" onclick="selectNote(this, 'toB', 'G')">G</div>
                    <div class="note-btn" data-note="G#" onclick="selectNote(this, 'toB', 'G#')">G#/Ab</div>
                    <div class="note-btn" data-note="A" onclick="selectNote(this, 'toB', 'A')">A</div>
                    <div class="note-btn" data-note="A#" onclick="selectNote(this, 'toB', 'A#')">A#/Bb</div>
                    <div class="note-btn" data-note="B" onclick="selectNote(this, 'toB', 'B')">B</div>
                </div>
                
                <div class="slider-container">
                    <input type="range" class="bpm-slider" id="targetSliderB" min="1" max="240" value="120" step="0.001" oninput="updateFromSlider('targetB')">
                    <div class="bpm-display" id="targetDisplayB" onclick="editBpm('targetB')">120.000</div>
                    <input type="number" class="bpm-input" id="targetInputB" min="1" max="999" step="0.001" onblur="finishEditBpm('targetB')" onkeydown="handleKeydown(event, 'targetB')">
                </div>
                
                <div class="bpm-controls">
                    <button class="bpm-btn" onclick="divideBpm('B')" title="BPM ÷ 2">÷2</button>
                    <button class="bpm-btn" onclick="multiplyBpm('B')" title="BPM × 2">×2</button>
                </div>
            </div>
        </div>

        <div class="results-container">
            <div class="result empty" id="resultA">
                <div class="result-main" style="color: rgba(255, 255, 255, 0.4); font-size: 12px; font-weight: 500;">
                    Configurez note/tempo de départ<br>puis votre cible désirée
                </div>
            </div>
            <div class="result empty" id="resultB">
                <div class="result-main" style="color: rgba(255, 255, 255, 0.4); font-size: 12px; font-weight: 500;">
                    Configurez note/tempo de départ<br>puis votre cible désirée
                </div>
            </div>
        </div>

        <div class="footer">
            <div class="middle-ground-container">
                <div class="middle-ground-buttons">
                    <button class="middle-ground-btn" id="middleBpmBtn" onclick="calculateMiddleGround('bpm')">⚡ BPM</button>
                    <button class="middle-ground-btn" id="middleKeyBtn" onclick="calculateMiddleGround('key')">🎵 Key</button>
                </div>
                <div class="suggestion-text" id="suggestionText"></div>
            </div>
            <button class="export-btn" onclick="exportResults()">📋 Export</button>
        </div>
    </div>

    <script>
        let selectedNotes = {
            fromA: 'A',
            toA: null,
            fromB: 'A',
            toB: null
        };

        let keyboardAcceleration = {
            currentA: { speed: 1, lastKeyTime: 0, accelerating: false },
            targetA: { speed: 1, lastKeyTime: 0, accelerating: false },
            currentB: { speed: 1, lastKeyTime: 0, accelerating: false },
            targetB: { speed: 1, lastKeyTime: 0, accelerating: false }
        };

        const noteValues = {
            'C': 0, 'C#': 1, 'D': 2, 'D#': 3, 'E': 4, 'F': 5,
            'F#': 6, 'G': 7, 'G#': 8, 'A': 9, 'A#': 10, 'B': 11
        };

        const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

        // Gestion des flèches du clavier avec accélération exponentielle
        document.addEventListener('keydown', function(event) {
            const focusedSlider = document.querySelector('.bpm-slider:focus');
            if (!focusedSlider || (event.key !== 'ArrowLeft' && event.key !== 'ArrowRight')) {
                return;
            }

            event.preventDefault();

            const sliderId = focusedSlider.id;
            let sliderType;
            if (sliderId === 'currentSliderA') sliderType = 'currentA';
            else if (sliderId === 'targetSliderA') sliderType = 'targetA';
            else if (sliderId === 'currentSliderB') sliderType = 'currentB';
            else if (sliderId === 'targetSliderB') sliderType = 'targetB';
            
            const acceleration = keyboardAcceleration[sliderType];
            
            const now = Date.now();
            const timeSinceLastKey = now - acceleration.lastKeyTime;
            
            // Si moins de 80ms depuis la dernière touche, on accélère exponentiellement
            if (timeSinceLastKey < 80 && acceleration.accelerating) {
                acceleration.speed = Math.min(acceleration.speed * 1.3, 20);
            } else {
                acceleration.speed = 1;
                acceleration.accelerating = true;
            }
            
            acceleration.lastKeyTime = now;
            
            // Calculer le pas avec accélération exponentielle
            let step = 0.1;
            if (acceleration.speed > 1) {
                step = 0.1 * Math.pow(acceleration.speed, 1.3);
            }
            
            const currentValue = parseFloat(focusedSlider.value);
            let newValue;
            
            if (event.key === 'ArrowRight') {
                newValue = Math.min(currentValue + step, 240);
            } else {
                newValue = Math.max(currentValue - step, 1);
            }
            
            focusedSlider.value = newValue;
            updateFromSlider(sliderType);
        });

        document.addEventListener('keyup', function(event) {
            if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
                setTimeout(() => {
                    Object.keys(keyboardAcceleration).forEach(key => {
                        keyboardAcceleration[key].accelerating = false;
                    });
                }, 200);
            }
        });

        function selectNote(element, type, note) {
            element.parentElement.querySelectorAll('.note-btn').forEach(btn => btn.classList.remove('selected'));
            element.classList.add('selected');
            selectedNotes[type] = note;
            
            // Animation de sélection
            element.style.transform = 'scale(0.9)';
            setTimeout(() => {
                element.style.transform = '';
            }, 150);
            
            // Si on sélectionne une note cible, calculer le BPM cible
            if (type.startsWith('to')) {
                const track = type.includes('A') ? 'A' : 'B';
                calculateTargetFromNote(track);
            }
            
            calculate();
            updateHarmonicIndicators();
        }

        function calculateTargetFromNote(track) {
            const currentBpm = parseFloat(document.getElementById('currentSlider' + track).value);
            const fromNote = selectedNotes['from' + track];
            const toNote = selectedNotes['to' + track];
            const fromDetune = parseFloat(document.getElementById('fromDetune' + track).value) || 0;
            
            if (currentBpm && fromNote && toNote) {
                const semitones = calculateSemitones(fromNote, toNote) + (fromDetune / 100);
                const multiplier = Math.pow(2, semitones / 12);
                const resultBpm = currentBpm * multiplier;
                
                document.getElementById('targetSlider' + track).value = Math.min(resultBpm, 240);
                document.getElementById('targetDisplay' + track).textContent = resultBpm.toFixed(3);
            }
        }

        function updateHarmonicIndicators() {
            const noteA = selectedNotes.fromA;
            const noteB = selectedNotes.fromB;
            const indicatorA = document.getElementById('harmonicA');
            const indicatorB = document.getElementById('harmonicB');
            
            // Vérifier la compatibilité harmonique
            const isCompatible = isHarmonicallyCompatible(noteA, noteB);
            
            if (isCompatible) {
                indicatorA.classList.add('compatible');
                indicatorB.classList.add('compatible');
            } else {
                indicatorA.classList.remove('compatible');
                indicatorB.classList.remove('compatible');
            }
        }

        function isHarmonicallyCompatible(noteA, noteB) {
            if (!noteA || !noteB) return false;
            
            // Méthode 1: Même note
            if (noteA === noteB) return true;
            
            // Méthode 2: Quintes/Quartes parfaites (±5/7 semitones)
            const semitonesDiff = Math.abs(calculateSemitones(noteA, noteB));
            if (semitonesDiff === 5 || semitonesDiff === 7) return true;
            
            // Méthode 3: Notes relatives (majeur/mineur relatif)
            const relativePairs = [
                ['C', 'Am'], ['C#', 'A#m'], ['D', 'Bm'], ['D#', 'Cm'],
                ['E', 'C#m'], ['F', 'Dm'], ['F#', 'D#m'], ['G', 'Em'],
                ['G#', 'Fm'], ['A', 'F#m'], ['A#', 'Gm'], ['B', 'G#m']
            ];
            
            for (const pair of relativePairs) {
                if ((pair[0] === noteA && pair[1] === noteB) || 
                    (pair[1] === noteA && pair[0] === noteB)) {
                    return true;
                }
            }
            
            // Méthode 4: Adjacent sur cercle de Camelot (±1 position)
            const camelotA = camelotWheel[noteA];
            const camelotB = camelotWheel[noteB];
            
            if (camelotA && camelotB) {
                const numA = parseInt(camelotA);
                const numB = parseInt(camelotB);
                const letterA = camelotA.slice(-1);
                const letterB = camelotB.slice(-1);
                
                // Même lettre (majeur/mineur), nombres adjacents
                if (letterA === letterB) {
                    const diff = Math.abs(numA - numB);
                    if (diff === 1 || diff === 11) return true; // 11 pour 1↔12
                }
                
                // Même nombre, lettres différentes (majeur↔mineur relatif)
                if (numA === numB && letterA !== letterB) return true;
            }
            
            return false;
        }

        function editBpm(type) {
            const display = document.getElementById(type.replace('current', 'currentDisplay').replace('target', 'targetDisplay'));
            const input = document.getElementById(type.replace('current', 'currentInput').replace('target', 'targetInput'));
            const currentValue = parseFloat(display.textContent);
            
            display.style.display = 'none';
            input.style.display = 'block';
            input.value = currentValue.toFixed(3);
            input.focus();
            input.select();
        }

        function finishEditBpm(type) {
            const display = document.getElementById(type.replace('current', 'currentDisplay').replace('target', 'targetDisplay'));
            const input = document.getElementById(type.replace('current', 'currentInput').replace('target', 'targetInput'));
            const slider = document.getElementById(type.replace('current', 'currentSlider').replace('target', 'targetSlider'));
            
            let value = parseFloat(input.value);
            if (isNaN(value) || value <= 0) {
                value = 120;
            }
            
            value = Math.max(1, Math.min(999, value));
            
            slider.value = Math.min(value, 240);
            display.textContent = value.toFixed(3);
            
            display.style.display = 'block';
            input.style.display = 'none';
            
            // Si on modifie le BPM cible, auto-sélectionner la note
            if (type.includes('target')) {
                const track = type.includes('A') ? 'A' : 'B';
                autoSelectNoteFromBpm(track);
            }
            
            // Mettre à jour la suggestion middle ground
            if (type.includes('current')) {
                updateMiddleGroundSuggestion();
            }
            
            calculate();
        }

        function handleKeydown(event, type) {
            if (event.key === 'Enter') {
                finishEditBpm(type);
            } else if (event.key === 'Escape') {
                const display = document.getElementById(type.replace('current', 'currentDisplay').replace('target', 'targetDisplay'));
                const input = document.getElementById(type.replace('current', 'currentInput').replace('target', 'targetInput'));
                
                display.style.display = 'block';
                input.style.display = 'none';
            }
        }

        function autoSelectNoteFromBpm(track) {
            const currentBpm = parseFloat(document.getElementById('currentSlider' + track).value);
            const targetBpm = parseFloat(document.getElementById('targetDisplay' + track).textContent);
            const fromNote = selectedNotes['from' + track];
            const fromDetune = parseFloat(document.getElementById('fromDetune' + track).value) || 0;
            
            if (currentBpm && targetBpm && fromNote && targetBpm !== currentBpm) {
                const speedRatio = targetBpm / currentBpm;
                const semitonesFloat = 12 * Math.log2(speedRatio) - (fromDetune / 100);
                const targetSemitones = Math.round(semitonesFloat);
                
                const fromNoteValue = noteValues[fromNote];
                let targetNoteValue = (fromNoteValue + targetSemitones) % 12;
                if (targetNoteValue < 0) targetNoteValue += 12;
                const suggestedNote = noteNames[targetNoteValue];
                
                const toGrid = document.getElementById('toGrid' + track);
                toGrid.querySelectorAll('.note-btn').forEach(btn => btn.classList.remove('selected'));
                
                const noteButton = toGrid.querySelector(`[data-note="${suggestedNote}"]`);
                if (noteButton) {
                    noteButton.classList.add('selected');
                    selectedNotes['to' + track] = suggestedNote;
                }
            }
        }

        function multiplyBpm(track) {
            const targetSlider = document.getElementById('targetSlider' + track);
            const targetDisplay = document.getElementById('targetDisplay' + track);
            
            const currentValue = parseFloat(targetDisplay.textContent) || 120;
            const newValue = Math.min(currentValue * 2, 999);
            targetSlider.value = Math.min(newValue, 240);
            targetDisplay.textContent = newValue.toFixed(3);
            
            autoSelectNoteFromBpm(track);
            calculate();
        }

        function divideBpm(track) {
            const targetSlider = document.getElementById('targetSlider' + track);
            const targetDisplay = document.getElementById('targetDisplay' + track);
            
            const currentValue = parseFloat(targetDisplay.textContent) || 120;
            const newValue = Math.max(currentValue / 2, 1);
            targetSlider.value = Math.min(newValue, 240);
            targetDisplay.textContent = newValue.toFixed(3);
            
            autoSelectNoteFromBpm(track);
            calculate();
        }

        function calculateSemitones(fromNote, toNote) {
            let from = noteValues[fromNote];
            let to = noteValues[toNote];
            let semitones = to - from;
            
            if (semitones > 6) semitones -= 12;
            if (semitones < -6) semitones += 12;
            
            return semitones;
        }

        function updateFromSlider(type) {
            const slider = document.getElementById(type.replace('current', 'currentSlider').replace('target', 'targetSlider'));
            const display = document.getElementById(type.replace('current', 'currentDisplay').replace('target', 'targetDisplay'));
            
            const value = parseFloat(slider.value);
            display.textContent = value.toFixed(3);
            
            // Si on modifie le BPM cible, auto-sélectionner la note
            if (type.includes('target')) {
                const track = type.includes('A') ? 'A' : 'B';
                autoSelectNoteFromBpm(track);
            }
            
            // Mettre à jour la suggestion middle ground
            if (type.includes('current')) {
                updateMiddleGroundSuggestion();
            }
            
            calculate();
        }

        function calculatePitchRange(percentChange) {
            // Déterminer automatiquement la range appropriée
            let recommendedRange = 6;
            if (Math.abs(percentChange) > 6) recommendedRange = 10;
            if (Math.abs(percentChange) > 10) recommendedRange = 16;
            if (Math.abs(percentChange) > 16) recommendedRange = 100;
            
            const pitchPosition = (percentChange / recommendedRange) * 100;
            const rangeDisplay = recommendedRange === 100 ? 'WIDE' : `±${recommendedRange}%`;
            
            return { 
                position: pitchPosition.toFixed(1), 
                range: rangeDisplay,
                inRange: Math.abs(pitchPosition) <= 100
            };
        }

        function calculate() {
            ['A', 'B'].forEach(track => {
                const currentBpm = parseFloat(document.getElementById('currentDisplay' + track).textContent);
                const targetBpm = parseFloat(document.getElementById('targetDisplay' + track).textContent);
                const fromNote = selectedNotes['from' + track];
                const toNote = selectedNotes['to' + track];
                const fromDetune = parseFloat(document.getElementById('fromDetune' + track).value) || 0;
                const resultDiv = document.getElementById('result' + track);
                
                if (!currentBpm || !fromNote || currentBpm === 0 || !toNote) {
                    resultDiv.className = 'result empty';
                    resultDiv.innerHTML = `
                        <div class="result-main" style="color: rgba(255, 255, 255, 0.4); font-size: 12px; font-weight: 500;">
                            Configurez note/tempo de départ<br>puis votre cible désirée
                        </div>
                    `;
                    return;
                }

                resultDiv.className = 'result';
                
                // Animation de mise à jour
                resultDiv.style.transform = 'scale(0.95)';
                setTimeout(() => {
                    resultDiv.style.transform = '';
                }, 150);

                const semitones = calculateSemitones(fromNote, toNote);
                const totalSemitones = semitones + (fromDetune / 100);
                const multiplier = Math.pow(2, totalSemitones / 12);
                const perfectBpm = currentBpm * multiplier;
                
                let displayBpm = targetBpm;
                let percentChange = ((targetBpm / currentBpm - 1) * 100);
                
                // Calculer les cents - limités à ±50
                let actualCents = 0;
                let isPerfect = Math.abs(targetBpm - perfectBpm) < 0.001;
                
                if (!isPerfect) {
                    const speedRatio = targetBpm / currentBpm;
                    const semitonesFloat = 12 * Math.log2(speedRatio);
                    const expectedSemitones = totalSemitones;
                    actualCents = (semitonesFloat - expectedSemitones) * 100;
                    
                    // Normaliser les cents dans la plage ±50
                    while (actualCents > 50) {
                        actualCents -= 100;
                    }
                    while (actualCents < -50) {
                        actualCents += 100;
                    }
                    
                    actualCents = Math.round(actualCents);
                }
                
                // Calculer la position pitch
                const pitchInfo = calculatePitchRange(percentChange);
                
                // Changer la classe du résultat selon la précision
                if (isPerfect) {
                    resultDiv.className = 'result perfect';
                } else {
                    resultDiv.className = 'result';
                }
                
                // Construire l'affichage des semitons avec signe
                let semitonesDisplay;
                if (totalSemitones > 0.005) {
                    semitonesDisplay = `+${totalSemitones.toFixed(2)} ST`;
                } else if (totalSemitones < -0.005) {
                    semitonesDisplay = `${totalSemitones.toFixed(2)} ST`;
                } else {
                    semitonesDisplay = `0.00 ST`;
                }
                
                // Construire l'affichage du pourcentage avec signe
                let percentDisplay;
                if (percentChange > 0.05) {
                    percentDisplay = `+${percentChange.toFixed(1)}%`;
                } else if (percentChange < -0.05) {
                    percentDisplay = `${percentChange.toFixed(1)}%`;
                } else {
                    percentDisplay = `0.0%`;
                }
                
                let resultHTML = `
                    <div class="result-main">${displayBpm.toFixed(3)} BPM</div>
                    <div class="result-details">
                        ${fromNote}${fromDetune !== 0 ? (fromDetune > 0 ? '+' + fromDetune : fromDetune) + 'CT' : ''} → ${toNote} (${semitonesDisplay})
                    `;

                // Afficher les cents avec signe
                let centsDisplay;
                if (actualCents > 0) {
                    centsDisplay = `+${actualCents} CT`;
                } else if (actualCents < 0) {
                    centsDisplay = `${actualCents} CT`;
                } else {
                    centsDisplay = `0 CT`;
                }
                resultHTML += `<br>${centsDisplay} • ${percentDisplay}`;
                
                // Ajouter les infos pitch
                resultHTML += `</div><div class="pitch-info">Pitch: ${pitchInfo.position > 0 ? '+' : ''}${pitchInfo.position}% (${pitchInfo.range})</div>`;
                
                resultDiv.innerHTML = resultHTML;
            });
        }

        function calculateMiddleGround(mode) {
            const bpmA = parseFloat(document.getElementById('currentDisplayA').textContent);
            const bpmB = parseFloat(document.getElementById('currentDisplayB').textContent);
            
            if (!bpmA || !bpmB || bpmA === 0 || bpmB === 0) {
                alert('Configurez d\'abord les BPM de départ des deux tracks');
                return;
            }
            
            const noteA = selectedNotes.fromA;
            const noteB = selectedNotes.fromB;
            const detuneA = parseFloat(document.getElementById('fromDetuneA').value) || 0;
            const detuneB = parseFloat(document.getElementById('fromDetuneB').value) || 0;
            
            if (mode === 'bpm') {
                // MIDDLE GROUND BPM: rapprocher au maximum les BPM avec notes justes
                // Chaque track trouve sa propre note optimale pour un BPM proche
                
                const targetBpmAverage = (bpmA + bpmB) / 2;
                
                // Pour chaque track, trouver la note qui donne le BPM le plus proche de la moyenne
                ['A', 'B'].forEach(track => {
                    const currentBpm = parseFloat(document.getElementById('currentDisplay' + track).textContent);
                    const fromNote = selectedNotes['from' + track];
                    const fromDetune = parseFloat(document.getElementById('fromDetune' + track).value) || 0;
                    
                    let bestOption = null;
                    let minBpmDeviation = Infinity;
                    
                    // Tester toutes les notes possibles pour ce track
                    for (let targetSemitone = 0; targetSemitone < 12; targetSemitone++) {
                        const targetNote = noteNames[targetSemitone];
                        
                        // Calculer le BPM exact pour atteindre cette note
                        const semitonesToTarget = calculateSemitones(fromNote, targetNote) - (fromDetune / 100);
                        const exactBpm = currentBpm * Math.pow(2, semitonesToTarget / 12);
                        
                        // Calculer la déviation par rapport au BPM moyen
                        const deviation = Math.abs(exactBpm - targetBpmAverage);
                        
                        // Garder la meilleure option
                        if (deviation < minBpmDeviation) {
                            minBpmDeviation = deviation;
                            bestOption = {
                                targetNote: targetNote,
                                exactBpm: exactBpm
                            };
                        }
                    }
                    
                    if (bestOption) {
                        // Appliquer la meilleure solution pour ce track
                        document.getElementById('targetDisplay' + track).textContent = bestOption.exactBpm.toFixed(3);
                        document.getElementById('targetSlider' + track).value = Math.min(bestOption.exactBpm, 240);
                        
                        // Sélectionner la note cible optimale pour ce track
                        const toGrid = document.getElementById('toGrid' + track);
                        toGrid.querySelectorAll('.note-btn').forEach(btn => btn.classList.remove('selected'));
                        const noteButton = toGrid.querySelector(`[data-note="${bestOption.targetNote}"]`);
                        if (noteButton) {
                            noteButton.classList.add('selected');
                            selectedNotes['to' + track] = bestOption.targetNote;
                        }
                    }
                });
                
            } else if (mode === 'key') {
                // MIDDLE GROUND KEY: même tonalité, BPM différent (keylock)
                
                // Calculer la note moyenne en prenant en compte le detune
                const centsA = (noteValues[noteA] * 100) + detuneA;
                const centsB = (noteValues[noteB] * 100) + detuneB;
                const middleCents = (centsA + centsB) / 2;
                const middleNoteCents = Math.round(middleCents / 100) * 100;
                let middleSemitones = middleNoteCents / 100;
                
                // Normaliser dans l'octave
                while (middleSemitones >= 12) middleSemitones -= 12;
                while (middleSemitones < 0) middleSemitones += 12;
                
                const middleNote = noteNames[middleSemitones];
                
                // Calculer les BPM nécessaires pour atteindre cette note
                const semitonesToMiddleA = calculateSemitones(noteA, middleNote) - (detuneA / 100);
                const semitonesToMiddleB = calculateSemitones(noteB, middleNote) - (detuneB / 100);
                
                const targetBpmA = bpmA * Math.pow(2, semitonesToMiddleA / 12);
                const targetBpmB = bpmB * Math.pow(2, semitonesToMiddleB / 12);
                
                document.getElementById('targetDisplayA').textContent = targetBpmA.toFixed(3);
                document.getElementById('targetSliderA').value = Math.min(targetBpmA, 240);
                document.getElementById('targetDisplayB').textContent = targetBpmB.toFixed(3);
                document.getElementById('targetSliderB').value = Math.min(targetBpmB, 240);
                
                // Sélectionner la note cible commune
                ['A', 'B'].forEach(track => {
                    const toGrid = document.getElementById('toGrid' + track);
                    toGrid.querySelectorAll('.note-btn').forEach(btn => btn.classList.remove('selected'));
                    const noteButton = toGrid.querySelector(`[data-note="${middleNote}"]`);
                    if (noteButton) {
                        noteButton.classList.add('selected');
                        selectedNotes['to' + track] = middleNote;
                    }
                });
            }
            
            calculate();
            updateHarmonicIndicators();
            
            // Feedback visuel
            const btn = document.getElementById(mode === 'bpm' ? 'middleBpmBtn' : 'middleKeyBtn');
            btn.style.transform = 'scale(0.95)';
            setTimeout(() => {
                btn.style.transform = '';
            }, 150);
        }

        function updateMiddleGroundSuggestion() {
            const bpmA = parseFloat(document.getElementById('currentDisplayA').textContent);
            const bpmB = parseFloat(document.getElementById('currentDisplayB').textContent);
            const noteA = selectedNotes.fromA;
            const noteB = selectedNotes.fromB;
            
            if (!bpmA || !bpmB || bpmA === 0 || bpmB === 0 || !noteA || !noteB) {
                document.getElementById('suggestionText').textContent = '';
                document.getElementById('middleBpmBtn').classList.remove('recommended');
                document.getElementById('middleKeyBtn').classList.remove('recommended');
                return;
            }
            
            const bpmDifference = Math.abs(bpmA - bpmB);
            const percentDifference = (bpmDifference / Math.min(bpmA, bpmB)) * 100;
            
            // Analyser l'intervalle harmonique
            const semitonesDiff = Math.abs(calculateSemitones(noteA, noteB));
            const isConsonant = [0, 5, 7].includes(semitonesDiff); // Unisson, quarte, quinte
            const isDissonant = [1, 6, 11].includes(semitonesDiff); // Demi-ton, triton, 7e maj
            
            const suggestionEl = document.getElementById('suggestionText');
            const bpmBtn = document.getElementById('middleBpmBtn');
            const keyBtn = document.getElementById('middleKeyBtn');
            
            // Reset styles
            bpmBtn.classList.remove('recommended');
            keyBtn.classList.remove('recommended');
            
            let recommendation = '';
            
            // Logique de recommandation améliorée
            if (percentDifference <= 15) {
                // Petit écart BPM
                if (isConsonant) {
                    recommendation = `Écart ${percentDifference.toFixed(1)}%, intervalle consonant → Repitch idéal`;
                    bpmBtn.classList.add('recommended');
                } else if (isDissonant) {
                    recommendation = `Écart ${percentDifference.toFixed(1)}%, intervalle dissonant → Keylock préférable`;
                    keyBtn.classList.add('recommended');
                } else {
                    recommendation = `Écart ${percentDifference.toFixed(1)}% → Repitch recommandé`;
                    bpmBtn.classList.add('recommended');
                }
            } else if (percentDifference <= 30) {
                // Écart moyen
                if (isConsonant) {
                    recommendation = `Écart ${percentDifference.toFixed(1)}%, intervalle consonant → Repitch viable`;
                    bpmBtn.classList.add('recommended');
                } else if (isDissonant) {
                    recommendation = `Écart ${percentDifference.toFixed(1)}%, intervalle dissonant → Keylock recommandé`;
                    keyBtn.classList.add('recommended');
                } else {
                    recommendation = `Écart ${percentDifference.toFixed(1)}% → Les deux options viables`;
                }
            } else {
                // Gros écart BPM
                if (isConsonant) {
                    recommendation = `Écart ${percentDifference.toFixed(1)}% → Repitch encore possible (intervalle facile)`;
                    bmpBtn.classList.add('recommended');
                } else {
                    recommendation = `Écart ${percentDifference.toFixed(1)}% → Keylock recommandé (gros écart)`;
                    keyBtn.classList.add('recommended');
                }
            }
            
            suggestionEl.textContent = recommendation;
        }

        function exportResults() {
            const trackA = getTrackData('A');
            const trackB = getTrackData('B');
            
            let exportText = `PITCH/TEMPO RESULTS\n`;
            exportText += `${new Date().toLocaleString()}\n\n`;
            
            if (trackA && trackA.hasData) {
                exportText += `TRACK A: ${trackA.fromNote} ${trackA.currentBpm} → ${trackA.toNote} ${trackA.targetBpm}\n`;
                exportText += `Change: ${trackA.semitones}ST ${trackA.percent} ${trackA.cents}CT\n`;
                exportText += `Pitch: ${trackA.pitchPosition}%\n\n`;
            }
            
            if (trackB && trackB.hasData) {
                exportText += `TRACK B: ${trackB.fromNote} ${trackB.currentBpm} → ${trackB.toNote} ${trackB.targetBpm}\n`;
                exportText += `Change: ${trackB.semitones}ST ${trackB.percent} ${trackB.cents}CT\n`;
                exportText += `Pitch: ${trackB.pitchPosition}%\n\n`;
            }
            
            if (trackA && trackA.hasData && trackB && trackB.hasData) {
                const compatible = isHarmonicallyCompatible(trackA.fromNote, trackB.fromNote);
                const camelotA = camelotWheel[trackA.fromNote] || 'N/A';
                const camelotB = camelotWheel[trackB.fromNote] || 'N/A';
                exportText += `Harmonic: ${compatible ? 'COMPATIBLE' : 'NOT COMPATIBLE'} (${camelotA}↔${camelotB})\n`;
            }
            
            if (!trackA || !trackA.hasData && !trackB || !trackB.hasData) {
                exportText += `Aucune donnée à exporter. Configurez au moins une track complètement.\n`;
            }
            
            // Télécharger le fichier
            const blob = new Blob([exportText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `pitch-calc.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function getTrackData(track) {
            const fromNote = selectedNotes['from' + track];
            const toNote = selectedNotes['to' + track];
            
            if (!fromNote || !toNote) {
                return { hasData: false };
            }
            
            const currentBpm = parseFloat(document.getElementById('currentDisplay' + track).textContent);
            const targetBpm = parseFloat(document.getElementById('targetDisplay' + track).textContent);
            const detune = parseFloat(document.getElementById('fromDetune' + track).value) || 0;
            
            if (!currentBpm || !targetBpm || currentBpm === 0 || targetBpm === 0) {
                return { hasData: false };
            }
            
            const semitones = calculateSemitones(fromNote, toNote) + (detune / 100);
            const percentChange = ((targetBpm / currentBpm - 1) * 100);
            const pitchInfo = calculatePitchRange(percentChange);
            
            // Calculer les cents
            const speedRatio = targetBpm / currentBpm;
            const semitonesFloat = 12 * Math.log2(speedRatio);
            let actualCents = (semitonesFloat - semitones) * 100;
            
            while (actualCents > 50) actualCents -= 100;
            while (actualCents < -50) actualCents += 100;
            actualCents = Math.round(actualCents);
            
            return {
                hasData: true,
                fromNote,
                toNote,
                currentBpm: currentBpm.toFixed(3),
                targetBpm: targetBpm.toFixed(3),
                detune,
                semitones: semitones > 0 ? `+${semitones.toFixed(2)}` : semitones.toFixed(2),
                percent: percentChange > 0 ? `+${percentChange.toFixed(1)}%` : `${percentChange.toFixed(1)}%`,
                cents: actualCents > 0 ? `+${actualCents}` : `${actualCents}`,
                pitchPosition: pitchInfo.position > 0 ? `+${pitchInfo.position}` : pitchInfo.position
            };
        }

        // Initialiser les valeurs par défaut
        window.addEventListener('load', () => {
            document.body.style.opacity = '0';
            document.body.style.transform = 'translateY(20px)';
            
            setTimeout(() => {
                document.body.style.transition = 'all 0.8s ease';
                document.body.style.opacity = '1';
                document.body.style.transform = 'translateY(0)';
            }, 100);
            
            calculate();
            updateHarmonicIndicators();
            updateMiddleGroundSuggestion();
        });
    </script>
</body>
</html>